/*
* Projeto: minDB
* Sistema Gerenciador de Banco de Dados Mínimo
*
* Direitos Autorais Reservados (c) 2016 Max Jeison Prass
*
* Você pode obter a última versão desse arquivo no GitHub
* localizado em https://bitbucket.org/jeisonmp/mindb
*
* Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la
* sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela
* Free Software Foundation; tanto a versão 2.1 da Licença, ou (a seu critério)
* qualquer versão posterior.
*
* Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM
* NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU
* ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor
* do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)
*
* Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto
* com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,
* no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.
* Você também pode obter uma copia da licença em:
* http://www.opensource.org/licenses/lgpl-license.php
*
* Max Jeison Prass, maxjeison@gmail.com
*
*/

#include <WinSock2.h>
#include <WS2tcpip.h>
#include <iostream>
#include <string>
#include <iostream>
#include "config.h"
#include "headers\Thread.h"
#include "headers\Server.h"
#include "headers\Bcp.h"
#include "headers\SGBD.h"
#include "headers\Requisition.h"

//A directiva pragma é usado para acessar as extensões de pré-processamento específicas do compilador.
//Um uso comum do #pragma é o #pragma once directiva, que pede o compilador para incluir um arquivo de cabeçalho apenas uma única vez, não importa quantas vezes ele foi importado.
#pragma comment(lib, "Ws2_32.lib")
using namespace std;

class SERVERTHREAD: public Thread
{
	Server server;

    public:
		SERVERTHREAD(Server server)
		{
			this->server = server;
			Thread::CreateNewThread(this);
		}

	void Run(void*)
	{
		if (!this->server.Recv())
		{
			return;
		}
		else
		{

		}
	}
};

int main()
{
	/*
	 * Inicia servidor
	 */
	Server server;

	/*
	 * Inicia servidor
	 */
	if (!server.Start())
	{
		return 1;
	}

	while (true)
	{
		/*
		 * Aguarda entrada de usuario e abre a thread para atende-la.
		 */
		if (!server.WaitClient())
		{
			//return 1; //fecha conexão
		}
		else
		{
			SERVERTHREAD *t = new SERVERTHREAD(server);
		}
	}

	server.Stop(NULL, "closed.");
	system("pause");

	return 1;
}